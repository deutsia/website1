<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S/HE IS STILL HER/E</title>
    <link rel="icon" type="image/webp" href="../assets/favi.webp">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #050508;
            color: rgba(255, 255, 255, 0.7);
        }

        .sky {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg,
                #0a0a12 0%,
                #080810 40%,
                #050508 100%
            );
            transition: background 1.5s ease;
            z-index: 0;
        }

        body.storm .sky {
            background: linear-gradient(180deg,
                #1a0505 0%,
                #0d0202 40%,
                #050000 100%
            );
        }

        .clouds-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            pointer-events: none;
            z-index: 1;
            opacity: 0.4;
            transition: opacity 1.5s ease, filter 1.5s ease;
        }

        body.storm .clouds-canvas {
            opacity: 0.6;
            filter: hue-rotate(-30deg) saturate(2) brightness(0.5);
        }

        .red-glow {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse 120% 80% at 50% 30%,
                rgba(139, 0, 0, 0.3) 0%,
                rgba(60, 0, 0, 0.15) 40%,
                transparent 70%
            );
            opacity: 0;
            pointer-events: none;
            z-index: 2;
            transition: opacity 1.2s ease;
        }

        body.storm .red-glow {
            opacity: 1;
        }

        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(0,0,0,0.6) 100%);
            pointer-events: none;
            z-index: 3;
            transition: background 1.5s ease;
        }

        body.storm .vignette {
            background: radial-gradient(ellipse at center, transparent 10%, rgba(0,0,0,0.85) 100%);
        }

        .ground-fog {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 25%;
            background: linear-gradient(to top,
                rgba(20, 20, 30, 0.4) 0%,
                transparent 100%
            );
            pointer-events: none;
            z-index: 4;
            transition: background 1.5s ease;
        }

        body.storm .ground-fog {
            background: linear-gradient(to top,
                rgba(60, 10, 10, 0.5) 0%,
                transparent 100%
            );
        }

        .container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 10;
        }

        .title {
            position: absolute;
            top: 48px;
            font-size: 14px;
            letter-spacing: 4px;
            opacity: 0;
            transition: opacity 0.5s ease, color 1.5s ease, text-shadow 1.5s ease;
            color: rgba(255, 255, 255, 0.8);
        }

        .title.visible {
            opacity: 0.9;
        }

        body.storm .title {
            color: #c6181a;
            text-shadow: 0 0 30px rgba(198,24,26,0.6);
        }

        .visualizer-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .circle {
            width: 120px;
            height: 120px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transition: transform 0.08s ease-out, border-color 1.5s ease, box-shadow 1.5s ease, background 1.5s ease;
            position: relative;
            background: transparent;
        }

        .circle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 3px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transition: background 1.5s ease, box-shadow 1.5s ease;
        }

        body.storm .circle {
            border-color: #c6181a;
            background: rgba(198, 24, 26, 0.05);
            box-shadow:
                0 0 60px rgba(198,24,26,0.5),
                0 0 120px rgba(198,24,26,0.25),
                inset 0 0 40px rgba(198,24,26,0.15);
        }

        body.storm .circle::before {
            background: #c6181a;
            box-shadow: 0 0 25px rgba(198,24,26,0.9);
        }

        .love-text {
            position: fixed;
            font-size: 10px;
            letter-spacing: 3px;
            color: rgba(255, 255, 255, 0.03);
            pointer-events: none;
            white-space: nowrap;
            transition: color 1.5s ease, text-shadow 1.5s ease;
        }

        body.storm .love-text {
            color: rgba(198, 24, 26, 0.4);
            text-shadow: 0 0 15px rgba(198,24,26,0.3);
        }

        .whisper {
            position: absolute;
            font-size: 11px;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.8s ease;
            pointer-events: none;
            white-space: nowrap;
            color: rgba(255, 255, 255, 0.6);
        }

        .whisper.visible {
            opacity: 0.6;
        }

        body.storm .whisper {
            color: #c6181a;
            text-shadow: 0 0 15px rgba(198,24,26,0.5);
        }

        .upload-hint {
            position: absolute;
            bottom: 48px;
            font-size: 11px;
            letter-spacing: 2px;
            opacity: 0.25;
            cursor: pointer;
            transition: opacity 0.3s ease, color 1.5s ease;
            color: rgba(255, 255, 255, 0.6);
        }

        .upload-hint:hover {
            opacity: 0.7;
        }

        .upload-hint.hidden {
            opacity: 0;
            pointer-events: none;
        }

        body.storm .upload-hint {
            color: rgba(198, 24, 26, 0.5);
        }

        #audioInput {
            display: none;
        }

        .drag-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .drag-overlay.active {
            display: flex;
        }

        .drag-text {
            font-size: 12px;
            letter-spacing: 4px;
            opacity: 0.5;
            color: rgba(255, 255, 255, 0.7);
        }

        .silhouette {
            position: fixed;
            bottom: 8%;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 250px;
            opacity: 0;
            pointer-events: none;
            z-index: 8;
            transition: opacity 2s ease;
        }

        .silhouette::before,
        .silhouette::after {
            content: '';
            position: absolute;
            bottom: 0;
            width: 50px;
            height: 160px;
            background: #000;
            border-radius: 25px 25px 0 0;
        }

        .silhouette::before {
            left: 40px;
            transform: rotate(-8deg);
        }

        .silhouette::after {
            right: 40px;
            transform: rotate(8deg);
        }

        body.storm .silhouette {
            opacity: 0.25;
        }

        .grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            opacity: 0.03;
            background-image: url('data:image/svg+xml,<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><filter id="noise"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" stitchTiles="stitch"/></filter><rect width="100%" height="100%" filter="url(%23noise)"/></svg>');
        }
    </style>
</head>
<body>
    <div class="sky"></div>
    <canvas class="clouds-canvas" id="cloudsCanvas"></canvas>
    <div class="red-glow"></div>
    <div class="vignette"></div>
    <div class="ground-fog"></div>
    <div class="silhouette"></div>
    <div class="grain"></div>

    <div class="container">
        <div class="title">S/HE IS STILL HER/E</div>

        <div class="visualizer-container">
            <div class="circle"></div>
        </div>

        <div class="upload-hint">drop audio or click</div>
    </div>

    <div class="drag-overlay">
        <span class="drag-text">release</span>
    </div>

    <input type="file" id="audioInput" accept="audio/*">
    <audio id="audio" crossorigin="anonymous"></audio>

    <script>
        // ===== CLOUD SYSTEM =====
        const canvas = document.getElementById('cloudsCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight * 0.6;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Cloud particles
        const clouds = [];
        const CLOUD_COUNT = 12;

        class Cloud {
            constructor() {
                this.reset(true);
            }

            reset(initial = false) {
                this.width = 150 + Math.random() * 250;
                this.height = 40 + Math.random() * 60;
                this.x = initial ? Math.random() * canvas.width : -this.width - 50;
                this.y = Math.random() * canvas.height * 0.7;
                this.speed = 0.15 + Math.random() * 0.35;
                this.opacity = 0.15 + Math.random() * 0.25;
                this.blur = 20 + Math.random() * 30;

                // Create cloud shape with multiple ellipses
                this.parts = [];
                const partCount = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < partCount; i++) {
                    this.parts.push({
                        offsetX: (i - partCount/2) * (this.width / partCount) * 0.6,
                        offsetY: (Math.random() - 0.5) * this.height * 0.4,
                        width: this.width * (0.4 + Math.random() * 0.3),
                        height: this.height * (0.6 + Math.random() * 0.4)
                    });
                }
            }

            update() {
                this.x += this.speed;
                if (this.x > canvas.width + 100) {
                    this.reset();
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.filter = `blur(${this.blur}px)`;
                ctx.globalAlpha = this.opacity;

                this.parts.forEach(part => {
                    ctx.beginPath();
                    ctx.ellipse(
                        this.x + part.offsetX,
                        this.y + part.offsetY,
                        part.width / 2,
                        part.height / 2,
                        0, 0, Math.PI * 2
                    );
                    ctx.fillStyle = 'rgba(180, 180, 190, 0.5)';
                    ctx.fill();
                });

                ctx.restore();
            }
        }

        // Initialize clouds
        for (let i = 0; i < CLOUD_COUNT; i++) {
            clouds.push(new Cloud());
        }

        function animateClouds() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            clouds.forEach(cloud => {
                cloud.update();
                cloud.draw(ctx);
            });

            requestAnimationFrame(animateClouds);
        }
        animateClouds();

        // ===== AUDIO VISUALIZER =====
        const whispers = [
            'still here',
            'watching',
            'listening',
            'waiting',
            'remember',
            'always',
            'never',
            'remain',
            'linger',
            'together'
        ];

        const loveFragments = [
            'in the name of love',
            'in the name',
            'of love',
            'the name',
            'love',
            'name',
            'in the',
            'of'
        ];

        let audioContext;
        let analyser;
        let dataArray;
        let audio = document.getElementById('audio');
        let circle = document.querySelector('.circle');
        let title = document.querySelector('.title');
        let uploadHint = document.querySelector('.upload-hint');
        let dragOverlay = document.querySelector('.drag-overlay');
        let audioInput = document.getElementById('audioInput');
        let container = document.querySelector('.container');

        let isPlaying = false;
        let loveTexts = [];

        // ===== BASS DETECTION =====
        let slowBaseline = 0;
        let isInDrop = false;
        let dropStartTime = 0;
        let lastWhisperTime = 0;
        let frameCount = 0;
        let energyHistory = [];
        let buildupDetected = false;

        const BASELINE_RISE_RATE = 0.002;
        const BASELINE_FALL_RATE = 0.02;
        const DROP_THRESHOLD_MULTIPLIER = 2.5;
        const DROP_ABSOLUTE_MIN = 120;
        const EXIT_THRESHOLD_MULTIPLIER = 1.5;
        const MIN_DROP_DURATION = 800;
        const BUILDUP_WINDOW = 90;

        // Scatter "in the name of love" across the page
        function createLoveTexts() {
            const positions = [
                { x: 8, y: 15 },
                { x: 78, y: 10 },
                { x: 88, y: 40 },
                { x: 5, y: 50 },
                { x: 92, y: 65 },
                { x: 10, y: 80 },
                { x: 72, y: 88 },
                { x: 38, y: 95 },
                { x: 55, y: 8 },
                { x: 3, y: 30 },
                { x: 85, y: 85 },
                { x: 22, y: 70 }
            ];

            positions.forEach((pos, i) => {
                const el = document.createElement('div');
                el.className = 'love-text';
                el.textContent = loveFragments[i % loveFragments.length];
                el.style.left = pos.x + '%';
                el.style.top = pos.y + '%';
                el.style.transform = `rotate(${(Math.random() - 0.5) * 25}deg)`;
                document.body.appendChild(el);
                loveTexts.push(el);
            });
        }

        createLoveTexts();

        // Show title on first hover
        let titleShown = false;
        document.addEventListener('mousemove', () => {
            if (!titleShown) {
                title.classList.add('visible');
                titleShown = true;
                setTimeout(() => {
                    title.classList.remove('visible');
                }, 3000);
            }
        });

        // File input handling
        uploadHint.addEventListener('click', () => {
            audioInput.click();
        });

        audioInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                loadAudio(e.target.files[0]);
            }
        });

        // Drag and drop
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            dragOverlay.classList.add('active');
        });

        document.addEventListener('dragleave', (e) => {
            if (e.relatedTarget === null) {
                dragOverlay.classList.remove('active');
            }
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            dragOverlay.classList.remove('active');

            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('audio/')) {
                loadAudio(file);
            }
        });

        function loadAudio(file) {
            const url = URL.createObjectURL(file);
            audio.src = url;

            if (!audioContext) {
                initAudio();
            }

            // Reset detection state
            slowBaseline = 0;
            energyHistory = [];
            buildupDetected = false;
            isInDrop = false;

            audio.play().then(() => {
                isPlaying = true;
                uploadHint.classList.add('hidden');
                title.classList.add('visible');
            });
        }

        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = 0.4;

            const source = audioContext.createMediaElementSource(audio);
            source.connect(analyser);
            analyser.connect(audioContext.destination);

            dataArray = new Uint8Array(analyser.frequencyBinCount);

            animateAudio();
        }

        function getSubBass() {
            let sum = 0;
            for (let i = 1; i <= 4; i++) {
                sum += dataArray[i];
            }
            return sum / 4;
        }

        function getBass() {
            let sum = 0;
            for (let i = 5; i <= 12; i++) {
                sum += dataArray[i];
            }
            return sum / 8;
        }

        function getMids() {
            let sum = 0;
            for (let i = 20; i <= 60; i++) {
                sum += dataArray[i];
            }
            return sum / 40;
        }

        function animateAudio() {
            requestAnimationFrame(animateAudio);

            if (!isPlaying || !analyser) return;

            analyser.getByteFrequencyData(dataArray);
            frameCount++;

            const subBass = getSubBass();
            const bass = getBass();
            const mids = getMids();
            const lowEnergy = (subBass * 2 + bass) / 3;

            energyHistory.push(lowEnergy);
            if (energyHistory.length > BUILDUP_WINDOW) {
                energyHistory.shift();
            }

            // Scale circle
            let scale = 1 + (lowEnergy / 255) * 0.7;
            circle.style.transform = `scale(${scale})`;

            // Update baseline asymmetrically
            if (lowEnergy > slowBaseline) {
                slowBaseline += (lowEnergy - slowBaseline) * BASELINE_RISE_RATE;
            } else {
                slowBaseline += (lowEnergy - slowBaseline) * BASELINE_FALL_RATE;
            }
            slowBaseline = Math.max(slowBaseline, 20);

            // Buildup detection
            if (energyHistory.length >= BUILDUP_WINDOW) {
                const firstHalf = energyHistory.slice(0, BUILDUP_WINDOW / 2);
                const secondHalf = energyHistory.slice(BUILDUP_WINDOW / 2);
                const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
                const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
                buildupDetected = secondAvg > firstAvg * 1.3 && secondAvg > 60;
            }

            const now = Date.now();
            const bassRatio = lowEnergy / Math.max(slowBaseline, 1);
            const isTrueBass = lowEnergy > mids * 0.8;

            if (!isInDrop) {
                const ratioTrigger = bassRatio > DROP_THRESHOLD_MULTIPLIER;
                const buildupTrigger = buildupDetected && lowEnergy > 100;
                const absoluteTrigger = lowEnergy > DROP_ABSOLUTE_MIN;

                if ((ratioTrigger || buildupTrigger) && absoluteTrigger && isTrueBass) {
                    enterDrop();
                    dropStartTime = now;
                    buildupDetected = false;
                }
            } else {
                const hasBeenInDropLongEnough = now - dropStartTime > MIN_DROP_DURATION;
                const bassDroppedOff = bassRatio < EXIT_THRESHOLD_MULTIPLIER && lowEnergy < 80;

                if (hasBeenInDropLongEnough && bassDroppedOff) {
                    exitDrop();
                }

                if (now - lastWhisperTime > 600 && Math.random() > 0.6) {
                    spawnWhisper();
                    lastWhisperTime = now;
                }
            }
        }

        function enterDrop() {
            isInDrop = true;
            document.body.classList.add('storm');
            title.classList.add('visible');
        }

        function exitDrop() {
            isInDrop = false;
            document.body.classList.remove('storm');
        }

        function spawnWhisper() {
            const whisper = document.createElement('div');
            whisper.className = 'whisper';
            whisper.textContent = whispers[Math.floor(Math.random() * whispers.length)];

            const angle = Math.random() * Math.PI * 2;
            const distance = 100 + Math.random() * 100;
            const x = Math.cos(angle) * distance;
            const y = Math.sin(angle) * distance;

            whisper.style.left = `calc(50% + ${x}px)`;
            whisper.style.top = `calc(50% + ${y}px)`;
            whisper.style.transform = `translate(-50%, -50%) rotate(${(Math.random() - 0.5) * 15}deg)`;

            container.appendChild(whisper);

            setTimeout(() => whisper.classList.add('visible'), 50);

            setTimeout(() => {
                whisper.classList.remove('visible');
                setTimeout(() => whisper.remove(), 800);
            }, 2000 + Math.random() * 1000);
        }

        audio.addEventListener('ended', () => {
            isPlaying = false;
            title.classList.remove('visible');
            uploadHint.classList.remove('hidden');
            exitDrop();
        });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && audio.src) {
                e.preventDefault();
                if (audio.paused) {
                    audio.play();
                    isPlaying = true;
                } else {
                    audio.pause();
                    isPlaying = false;
                }
            }
        });

        document.addEventListener('contextmenu', (e) => e.preventDefault());
    </script>
</body>
</html>
